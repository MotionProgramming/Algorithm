
// altime better recursive way Depth First Searach

#include <bits/stdc++.h>  
using namespace std;  

typedef vector<int> vi;  
map<int, vi> adj; // Adjacency list  
map<int, bool> visited; // To track visited nodes  

#define PB push_back  
#define endl '\n'  
#define optimize() ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);  

// Add undirected edge  
void edge(int u, int v) {  
    adj[u].PB(v); // Add v to u's adjacency list  
    adj[v].PB(u); // Add u to v's adjacency list  
}  

// Iterative DFS using stack  
void DFS(int start) {  
    stack<int> s;  
    s.push(start); // Push start node  
    visited[start] = true; // Mark as visited  
    
    while (!s.empty()) {  
        cout << s.top() << " "; // Print top node  
        for (auto x : adj[s.top()]) { // Explore neighbors  
            if (!visited[x]) {  
                visited[x] = true; // Mark neighbor as visited  
                s.push(x); // Push neighbor to stack  
            }  
        }  
        s.pop(); // Remove processed node  
    }  
}  



// Recursive DFS function
void DFS(int start) {
    visited[start] = true; // Mark the current node as visited
    cout << start << " ";  // Print the current node
    
    // Recur for all the vertices adjacent to this vertex
    for (auto x : adj[start]) { 
        if (!visited[x]) {  // If the adjacent node has not been visited
            DFS(x);  // Recur with the adjacent node
        }
    }
}


// Input and DFS execution  
void solve() {  
    int n, u, v, start;  
    cin >> n; 
    cout << "Enter the number of edges: " << n << endl;  
    
    for (int i = 0; i < n; i++) {  
        cin >> u >> v;  
        edge(u, v); // Add each edge  
    }  
    
    cin >> start; // Read starting node  
    cout << "DFS starting from node " << start << ": ";  
    DFS(start);  
    cout << endl;  
}  

// Main function  
int main() {  
    optimize(); 
    solve(); 
    return 0;  
}  
